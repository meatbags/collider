var Collider=function(t){var s={};function i(e){if(s[e])return s[e].exports;var n=s[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=t,i.c=s,i.d=function(t,s,e){i.o(t,s)||Object.defineProperty(t,s,{enumerable:!0,get:e})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,s){if(1&s&&(t=i(t)),8&s)return t;if(4&s&&"object"==typeof t&&t&&t.__esModule)return t;var e=Object.create(null);if(i.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:t}),2&s&&"string"!=typeof t)for(var n in t)i.d(e,n,function(s){return t[s]}.bind(null,n));return e},i.n=function(t){var s=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(s,"a",s),s},i.o=function(t,s){return Object.prototype.hasOwnProperty.call(t,s)},i.p="",i(i.s=0)}([function(t,s,i){"use strict";i.r(s);var e={system:{maxPlanesPerMesh:200,useCache:!1,cacheRadius:20},settings:{gravity:10,floor:0,maxVelocity:50,friction:.5,snapUp:.75,snapDown:.5,minSlope:Math.PI/5,noclip:!1},plane:{dotThreshold:.001,collisionThreshold:.5}};Math.PI;const n=function(t,s){return new THREE.Vector3(t.x+s.x,t.y+s.y,t.z+s.z)},o=function(t,s){return new THREE.Vector3(t.x-s.x,t.y-s.y,t.z-s.z)},r=function(t){const s=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);return 0==s?new THREE.Vector3(0,0,0):new THREE.Vector3(t.x/s,t.y/s,t.z/s)},h=function(t){return t.x*=-1,t.y*=-1,t.z*=-1,t},l=function(t,s){return Math.sqrt(Math.pow(s.x-t.x,2)+Math.pow(s.y-t.y,2)+Math.pow(s.z-t.z,2))},a=function(t,s){return new THREE.Vector3(t.x*s,t.y*s,t.z*s)},p=function(t,s){return new THREE.Vector3(t.x*s.x,t.y*s.y,t.z*s.z)},c=function(t,s){return t.x===s.x&&t.y===s.y&t.z===s.z},x=function(t,s){return new THREE.Vector3(t.y*s.z-t.z*s.y,t.z*s.x-t.x*s.z,t.x*s.y-t.y*s.x)},m=function(t,s){return t.x*s.x+t.y*s.y+t.z*s.z},y=function(t,s){return t.x*s.x+t.y*s.y};var u=class{constructor(t,s,i,e,n,o){this.p1=t,this.p2=s,this.p3=i,this.n1=e,this.n2=n,this.n3=o,this.culled=!1,this.generatePlane()}generatePlane(){this.e1={},this.e2={},this.e3={},this.e1.centre=a(n(this.p1,this.p2),.5),this.e2.centre=a(n(this.p2,this.p3),.5),this.e3.centre=a(n(this.p3,this.p1),.5),this.e1.vec=o(this.p2,this.p1),this.e2.vec=o(this.p3,this.p2),this.e3.vec=o(this.p1,this.p3),this.e1.vec2=new THREE.Vector2(this.e1.vec.x,this.e1.vec.z),this.e2.vec2=new THREE.Vector2(this.e2.vec.x,this.e2.vec.z),this.e3.vec2=new THREE.Vector2(this.e3.vec.x,this.e3.vec.z),this.e1.norm2=new THREE.Vector2(-this.e1.vec.z,this.e1.vec.x),this.e2.norm2=new THREE.Vector2(-this.e2.vec.z,this.e2.vec.x),this.e3.norm2=new THREE.Vector2(-this.e3.vec.z,this.e3.vec.x),this.normal=r(x(this.e3.vec,this.e1.vec)),this.normalXZ=new THREE.Vector3(this.normal.x,0,this.normal.z),m(this.normal,this.n1)<0&&m(this.normal,this.n2)<0&&m(this.normal,this.n3)<0&&(this.normal=h(this.normal)),this.position=new THREE.Vector3((this.p1.x+this.p2.x+this.p3.x)/3,(this.p1.y+this.p2.y+this.p3.y)/3,(this.p1.z+this.p2.z+this.p3.z)/3),this.D=-this.normal.x*this.position.x-this.normal.y*this.position.y-this.normal.z*this.position.z,this.box=(new THREE.Box3).setFromPoints([this.p1,this.p2,this.p3])}getY(t,s){return 0!=this.normal.y?(this.normal.x*t+this.normal.z*s+this.D)/-this.normal.y:null}isPlaneAbove(t){return this.isPointAboveOrEqual(t.p1)&&this.isPointAboveOrEqual(t.p2)&&this.isPointAboveOrEqual(t.p3)}isPointAboveOrEqual(t){return m(o(t,this.position),this.normal)>=-e.plane.dotThreshold}isPointBelowOrEqual(t){return m(o(t,this.position),this.normal)<=e.plane.dotThreshold}containsBox(t){return this.box.containsBox(t)}intersectsBox(t){return this.box.intersectsBox(t)}containsPoint2D(t){return this.box.min.x<=t.x&&this.box.max.x>=t.x&&this.box.min.z<=t.z&&this.box.max.z>=t.z}projectedTriangleContainsPoint2D(t){return y({x:t.x-this.e1.centre.x,y:t.z-this.e1.centre.z},this.e1.norm2)<e.plane.dotThreshold&&y({x:t.x-this.e2.centre.x,y:t.z-this.e2.centre.z},this.e2.norm2)<e.plane.dotThreshold&&y({x:t.x-this.e3.centre.x,y:t.z-this.e3.centre.z},this.e3.norm2)<e.plane.dotThreshold}distanceToPlane(t){return Math.abs(this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D)}getProjected(t){const s=o(t,this.p1),i=m(this.normal,s);return o(t,a(this.normal,i))}getIntersect(t,s){const i=o(s,t),n=m(this.normal,r(i));if(Math.abs(n)<=e.plane.dotThreshold)return null;const h=this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D,l=this.normal.x*i.x+this.normal.y*i.y+this.normal.z*i.z;if(0==l)return null;const a=t.x-i.x*h/l,p=t.y-i.y*h/l,c=t.z-i.z*h/l,x=new THREE.Vector3(a,p,c);return this.box.containsPoint(x)&&(new THREE.Box3).setFromPoints([s,t]).expandByScalar(.05).containsPoint(x)?x:null}getNormalIntersect(t){const s=n(t,this.normal),i=o(s,t),e=this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D,r=this.normal.x*i.x+this.normal.y*i.y+this.normal.z*i.z,h=t.x-i.x*e/r,l=t.y-i.y*e/r,a=t.z-i.z*e/r;return new THREE.Vector3(h,l,a)}getNormalIntersect2D(t){const s=this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D,i=this.normal.x*this.normal.x+this.normal.z*this.normal.z;return 0==i?null:new THREE.Vector3(t.x-this.normal.x*s/i,t.y,t.z-this.normal.z*s/i)}getPerpendicularNormals(){return{right:new THREE.Vector3(-this.normal.z,0,this.normal.x),left:new THREE.Vector3(this.normal.z,0,-this.normal.x)}}};var g=class extends THREE.Box3{constructor(t){super(),this.setFromBufferAttribute(t.geometry.attributes.position),this.position=new THREE.Vector3}setPosition(t){c(this.position,t)||(this.translate(o(t,this.position)),this.position=t.clone())}distanceTo(t){return this.position.distanceTo(t)}};var f=class{constructor(t){this.point=new THREE.Vector3,this.position=t.position,this.rotation=t.rotation,this.scale=t.scale,this.rotationOrder=t.rotation.order.split(""),this.axis={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)},this.checkDefault()}set(t){this.point.x=t.x-this.position.x,this.point.y=t.y-this.position.y,this.point.z=t.z-this.position.z}getTransformedPoint(t){return{x:t.x-this.position.x,y:t.y-this.position.y,z:t.z-this.position.z}}getReverseTransformedPoint(t){return{x:t.x+this.position.x,y:t.y+this.position.y,z:t.z+this.position.z}}getReverseTransformedY(t){return t+this.position.y}getPosition(){return this.position}bakeRotation(t){for(let s=this.rotationOrder.length-1,i=-1;s>i;--s)"X"==this.rotationOrder[s]?(t.p1.applyAxisAngle(this.axis.x,this.rotation.x),t.p2.applyAxisAngle(this.axis.x,this.rotation.x),t.p3.applyAxisAngle(this.axis.x,this.rotation.x),t.n1.applyAxisAngle(this.axis.x,this.rotation.x),t.n2.applyAxisAngle(this.axis.x,this.rotation.x),t.n3.applyAxisAngle(this.axis.x,this.rotation.x)):"Y"==this.rotationOrder[s]?(t.p1.applyAxisAngle(this.axis.y,this.rotation.y),t.p2.applyAxisAngle(this.axis.y,this.rotation.y),t.p3.applyAxisAngle(this.axis.y,this.rotation.y),t.n1.applyAxisAngle(this.axis.y,this.rotation.y),t.n2.applyAxisAngle(this.axis.y,this.rotation.y),t.n3.applyAxisAngle(this.axis.y,this.rotation.y)):"Z"==this.rotationOrder[s]&&(t.p1.applyAxisAngle(this.axis.z,this.rotation.z),t.p2.applyAxisAngle(this.axis.z,this.rotation.z),t.p3.applyAxisAngle(this.axis.z,this.rotation.z),t.n1.applyAxisAngle(this.axis.z,this.rotation.z),t.n2.applyAxisAngle(this.axis.z,this.rotation.z),t.n3.applyAxisAngle(this.axis.z,this.rotation.z))}bakeScale(t){t.p1=p(t.p1,this.scale),t.p2=p(t.p2,this.scale),t.p3=p(t.p3,this.scale)}checkDefault(){this.default={position:0==this.position.x&&0==this.position.y&&0==this.position.z,rotation:0==this.rotation.x&&0==this.rotation.y&&0==this.rotation.z,scale:1==this.scale.x&&1==this.scale.y&&1==this.scale.z}}};var d=class{constructor(t){if(!t.geometry.isBufferGeometry)throw"Error: THREE.BufferGeometry not found";this.id=t.uuid,this.isColliderMesh=!0,this.object=t,this.geometry=t.geometry,this.box=new g(t),this.planes=[],this.transform=new f(t),this.generatePlanes(),this.conformPlanes()}generatePlanes(){const t=this.geometry.attributes.position.array,s=this.geometry.attributes.normal.array;if(this.geometry.index){const i=this.geometry.index.array,e=this.geometry.attributes.position.itemSize,n=3;for(let o=0;o<i.length;o+=n){const n=i[o]*e,r=i[o+1]*e,h=i[o+2]*e;this.planes.push(new u(new THREE.Vector3(t[n],t[n+1],t[n+2]),new THREE.Vector3(t[r],t[r+1],t[r+2]),new THREE.Vector3(t[h],t[h+1],t[h+2]),new THREE.Vector3(s[n],s[n+1],s[n+2]),new THREE.Vector3(s[r],s[r+1],s[r+2]),new THREE.Vector3(s[h],s[h+1],s[h+2])))}}else{const i=9;for(let e=0;e<t.length;e+=i)this.planes.push(new u(new THREE.Vector3(t[e+0],t[e+1],t[e+2]),new THREE.Vector3(t[e+3],t[e+4],t[e+5]),new THREE.Vector3(t[e+6],t[e+7],t[e+8]),new THREE.Vector3(s[e+0],s[e+1],s[e+2]),new THREE.Vector3(s[e+3],s[e+4],s[e+5]),new THREE.Vector3(s[e+6],s[e+7],s[e+8])))}}conformPlanes(){var t=!1;if(!this.transform.default.scale){for(let t=0;t<this.planes.length;t+=1)this.transform.bakeScale(this.planes[t]);t=!0}if(!this.transform.default.rotation){for(let t=0;t<this.planes.length;t+=1)this.transform.bakeRotation(this.planes[t]);t=!0}if(t)for(let t=0;t<this.planes.length;t+=1)this.planes[t].generatePlane();this.setBoxFromPlanes()}setBoxFromPlanes(){const t=[];for(var s=0,i=this.planes.length;s<i;++s){const i=this.planes[s];t.push(i.p1),t.push(i.p2),t.push(i.p3)}this.box.setFromPoints(t),this.updateBoxPosition()}updateBoxPosition(){this.box.setPosition(this.transform.getPosition())}getCollision(t){if(this.box.containsPoint(t)){this.transform.set(t);for(var s=0,i=this.planes.length;s<i;++s)this.planes[s].culled=!1;for(s=0,i=this.planes.length;s<i;++s)if(!this.planes[s].culled&&this.planes[s].isPointBelowOrEqual(this.transform.point))for(var e=0,n=this.planes.length;e<n;++e)!this.planes[e].culled&&e!=s&&this.planes[s].isPlaneAbove(this.planes[e])&&(this.planes[e].culled=!0);for(s=0,i=this.planes.length;s<i;++s)if(!this.planes[s].culled&&!this.planes[s].isPointBelowOrEqual(this.transform.point))return!1;return!0}return!1}getCeilingPlane(t){this.transform.set(t);var s=null;for(let t=0,e=this.planes.length;t<e;t+=1)if(this.planes[t].containsPoint2D(this.transform.point)&&this.planes[t].projectedTriangleContainsPoint2D(this.transform.point)&&this.planes[t].isPointBelowOrEqual(this.transform.point)){var i=this.planes[t].getY(this.transform.point.x,this.transform.point.z);null!=i&&i>=this.transform.point.y&&(null==s||i>s.y)&&(s={y:i,plane:this.planes[t]})}return null==s?null:{y:this.transform.getReverseTransformedY(s.y),plane:s.plane}}getIntersectPlane(t,s){const i=this.transform.getTransformedPoint(t),e=this.transform.getTransformedPoint(s),n=(new THREE.Box3).setFromPoints([i,e]);let o=null;for(let t=0;t<this.planes.length;t+=1)if(this.planes[t].intersectsBox(n)||this.planes[t].containsBox(n)){const s=this.planes[t].getIntersect(i,e);if(null!=s){const e=l(i,s);(null===o||e<o.distance)&&(o={intersect:s,plane:this.planes[t],distance:e})}}return null==o?null:{intersect:this.transform.getReverseTransformedPoint(o.intersect),plane:o.plane,distance:o.distance}}getIntersectPlane2D(t,s){const i=this.transform.getTransformedPoint(t),e=this.transform.getTransformedPoint(s),n=(new THREE.Box3).setFromPoints([i,e]);let o=null;for(let t=0;t<this.planes.length;t+=1)if(this.planes[t].intersectsBox(n)||this.planes[t].containsBox(n)){const s=this.planes[t].getNormalIntersect2D(e);if(null!=s){const i=l(e,s);(null===o||i<o.distance)&&(o={plane:this.planes[t],intersect:s,distance:i})}}return null==o?null:{intersect:this.transform.getReverseTransformedPoint(o.intersect),plane:o.plane,distance:o.distance}}getProjected(t,s){const i=this.transform.getTransformedPoint(t),e=s.getProjected(i);return this.transform.getReverseTransformedPoint(e)}distanceTo(t){return this.box.distanceTo(t)}};var z=class{constructor(){this.meshes=[],this.cache=[],this.settings=e.system,this.isColliderSystem=!0}add(){for(let t=0,s=arguments.length;t<s;++t){let s=arguments[t];!s.isColliderMesh&&s.geometry&&s.geometry.isBufferGeometry&&(s=new d(s)),s.isColliderMesh&&(s.planes.length<e.system.maxPlanesPerMesh?this.meshes.push(s):console.warn(`Mesh plane count exceeds maximum (${e.system.maxPlanesPerMesh})`))}}getCollisions(t){const s=[],i=this.settings.useCache?this.cache:this.meshes;for(let e=0,n=i.length;e<n;++e)i[e].getCollision(t)&&s.push(i[e]);return s}getCeilingPlane(t){let s=null;const i=this.getCollisions(t);for(let e=0,n=i.length;e<n;++e){const n=i[e].getCeilingPlane(t);n&&(!s||n.y>s.y)&&(s={y:n.y,plane:n.plane})}return s}cache(t){this.cache=[];for(let s=0,i=this.meshes.length;s<i;++s)this.meshes[s].distanceTo(t)<this.settings.cacheRadius&&this.cache.push(this.meshes[s])}};var E=class{constructor(t){this.settings=e.settings,this.set(t||{})}set(t){Object.keys(t).forEach(s=>{void 0!==this.settings[s]&&typeof this.settings[s]==typeof t[s]&&(this.settings[s]=t[s])}),this.position=t.position||new THREE.Vector3,this.motion=t.motion||new THREE.Vector3,this.system=t.system||null}collide(t){if(!this.system)return;const s=n(this.position,a(this.motion,t));this.falling=this.motion.y<0,this.motion.y=Math.max(this.motion.y-this.settings.gravity*t,-this.settings.maxVelocity);let i=this.system.getCollisions(s);i.length>0?(this.stepUpSlopes(s,i)&&(i=this.system.getCollisions(s)),this.extrudeFrom(s,i)&&this.stepUpSlopes(s,this.system.getCollisions(s))):this.motion.y<0&&!this.falling&&this.stepDownSlope(s,this.system.getCeilingPlane(new THREE.Vector3(s.x,s.y-this.settings.snapDown,s.z))),s.y<this.settings.floor&&(this.motion.y=0,s.y=this.settings.floor),this.position.copy(s)}getValidCollisions(t,s){for(var i=0,e=0,n=s.length;e<n;++e){const n=s[e].getCeilingPlane(t);null!=n&&(n.plane.normal.y<this.settings.minSlope||n.y-this.position.y>this.settings.snapUp)&&i++}return i}extrudeFrom(t,s){var i=!1,e=!1;for(let i=0,n=s.length;i<n;++i){const n=s[i].getCeilingPlane(t);if(null!=n&&(n.plane.normal.y<this.settings.minSlope||n.y-this.position.y>this.settings.snapUp)){e=s[i];break}}if(e){const s=e.getIntersectPlane2D(this.position,t);if(null!=s){const n=s.intersect,o=s.plane;if(o.normal.y<-.5){const s=e.getProjected(t,o);this.getValidCollisions(s,this.system.getCollisions(s))>1?(t.x=this.position.x,t.z=this.position.z):(t.x=s.x,t.y=s.y,t.z=s.z,this.motion.y=this.motion.y>0?.75*this.motion.y:this.motion.y,i=!0)}else t.x=n.x,t.z=n.z,this.getValidCollisions(t,this.system.getCollisions(t))>1?(t.x=this.position.x,t.z=this.position.z):i=!0}else t.x=this.position.x,t.z=this.position.z}return i}stepUpSlopes(t,s){let i=!1;for(let e=0,n=s.length;e<n;++e){const n=s[e].getCeilingPlane(t);null!=n&&n.plane.normal.y>=this.settings.minSlope&&n.y-this.position.y<=this.settings.snapUp&&n.y>=t.y&&(i=!0,t.y=n.y,this.motion.y=0)}return i}stepDownSlope(t,s){let i=!1;return null!=s&&s.plane.normal.y>=this.settings.minSlope&&(t.y=s.y,this.motion.y=0,i=!0),i}};i.d(s,"System",function(){return z}),i.d(s,"Point",function(){return E})}]);