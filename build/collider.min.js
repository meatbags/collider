var Collider =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules */ \"./src/modules/index.js\");\n/* empty/unused harmony star reexport */\n\n//# sourceURL=webpack://Collider/./src/app.js?");

/***/ }),

/***/ "./src/modules/config.js":
/*!*******************************!*\
  !*** ./src/modules/config.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Defaults */\n\nconst Config = {\n  system: {\n    maxPlanesPerMesh: 200,\n    useCache: false,\n    cacheRadius: 20\n  },\n  settings: {\n    gravity: 10,\n    floor: 0,\n    maxVelocity: 50,\n    friction: 0.5,\n    snapUp: 0.75,\n    snapDown: 0.5,\n    minSlope: Math.PI / 5,\n    noclip: false\n  },\n  plane: {\n    dotThreshold: 0.001,\n    collisionThreshold: 0.5\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Config);\n\n//# sourceURL=webpack://Collider/./src/modules/config.js?");

/***/ }),

/***/ "./src/modules/index.js":
/*!******************************!*\
  !*** ./src/modules/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./system */ \"./src/modules/system.js\");\n/* empty/unused harmony star reexport *//* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point */ \"./src/modules/point.js\");\n/* empty/unused harmony star reexport */\n\n\n//# sourceURL=webpack://Collider/./src/modules/index.js?");

/***/ }),

/***/ "./src/modules/maths/general.js":
/*!**************************************!*\
  !*** ./src/modules/maths/general.js ***!
  \**************************************/
/*! exports provided: addVector, averageVectors, copyVector, crossProduct, distanceBetween, distanceBetween2D, dotProduct, dotProduct2, isVectorEqual, minAngleDifference, mulVector, normalise, normalise2, pitchBetween, reverseVector, subtractVector, scaleVector, scaleByVector, twoPi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addVector\", function() { return addVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"averageVectors\", function() { return averageVectors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copyVector\", function() { return copyVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"crossProduct\", function() { return crossProduct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distanceBetween\", function() { return distanceBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distanceBetween2D\", function() { return distanceBetween2D; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dotProduct\", function() { return dotProduct; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dotProduct2\", function() { return dotProduct2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isVectorEqual\", function() { return isVectorEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"minAngleDifference\", function() { return minAngleDifference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mulVector\", function() { return mulVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalise\", function() { return normalise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalise2\", function() { return normalise2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pitchBetween\", function() { return pitchBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reverseVector\", function() { return reverseVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtractVector\", function() { return subtractVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleVector\", function() { return scaleVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleByVector\", function() { return scaleByVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"twoPi\", function() { return twoPi; });\n/** Useful maths */\n\nconst twoPi = Math.PI * 2;\n\nconst copyVector = function (vec) {\n  const copied = new THREE.Vector3(vec.x, vec.y, vec.z);\n\n  return copied;\n};\n\nconst addVector = function (a, b) {\n  return new THREE.Vector3(a.x + b.x, a.y + b.y, a.z + b.z);\n};\n\nconst averageVectors = function (a, b) {\n  return new THREE.Vector3((a.x + b.x) / 2, (a.y + b.y) / 2, (a.z + b.z) / 2);\n};\n\nconst subtractVector = function (a, b) {\n  const c = new THREE.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\n\n  return c;\n};\n\nconst mulVector = function (a, b) {\n  const v = new THREE.Vector3(a.x * b.x, a.y * b.y, a.z * b.z);\n\n  return v;\n};\n\nconst normalise = function (a) {\n  const mag = Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n  if (mag == 0) {\n    return new THREE.Vector3(0, 0, 0);\n  } else {\n    return new THREE.Vector3(a.x / mag, a.y / mag, a.z / mag);\n  }\n};\n\nconst normalise2 = function (a) {\n  const mag = Math.sqrt(a.x * a.x + a.y * a.y);\n\n  if (mag == 0) {\n    return new THREE.Vector2(0, 0);\n  } else {\n    return new THREE.Vector2(a.x / mag, a.y / mag);\n  }\n};\n\nconst reverseVector = function (a) {\n  a.x *= -1;\n  a.y *= -1;\n  a.z *= -1;\n\n  return a;\n};\n\nconst distanceBetween = function (a, b) {\n  return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2) + Math.pow(b.z - a.z, 2));\n};\n\nconst distanceBetween2D = function (a, b) {\n  return Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.z - a.z, 2));\n};\n\nconst pitchBetween = function (a, b) {\n  const xz = distanceBetween2D(a, b);\n  const y = b.y - a.y;\n  const pitch = Math.atan2(y, xz);\n\n  return pitch;\n};\n\nconst scaleVector = function (v, scale) {\n  const vec = new THREE.Vector3(v.x * scale, v.y * scale, v.z * scale);\n\n  return vec;\n};\n\nconst scaleByVector = function (v, scale) {\n  const vec = new THREE.Vector3(v.x * scale.x, v.y * scale.y, v.z * scale.z);\n\n  return vec;\n};\n\nconst isVectorEqual = function (a, b) {\n  return a.x === b.x && a.y === b.y & a.z === b.z;\n};\n\nconst crossProduct = function (a, b) {\n  const c = new THREE.Vector3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);\n\n  return c;\n};\n\nconst minAngleDifference = function (a1, a2) {\n  const angle = Math.atan2(Math.sin(a2 - a1), Math.cos(a2 - a1));\n\n  return angle;\n};\n\nconst dotProduct = function (a, b) {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n};\n\nconst dotProduct2 = function (a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n\n\n\n//# sourceURL=webpack://Collider/./src/modules/maths/general.js?");

/***/ }),

/***/ "./src/modules/maths/index.js":
/*!************************************!*\
  !*** ./src/modules/maths/index.js ***!
  \************************************/
/*! exports provided: addVector, averageVectors, copyVector, crossProduct, distanceBetween, distanceBetween2D, dotProduct, dotProduct2, isVectorEqual, minAngleDifference, mulVector, normalise, normalise2, pitchBetween, reverseVector, subtractVector, scaleVector, scaleByVector, twoPi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./general */ \"./src/modules/maths/general.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"addVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"addVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"averageVectors\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"averageVectors\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"copyVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"copyVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"crossProduct\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"crossProduct\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"distanceBetween\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"distanceBetween\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"distanceBetween2D\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"distanceBetween2D\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"dotProduct\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"dotProduct2\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"isVectorEqual\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"isVectorEqual\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"minAngleDifference\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"minAngleDifference\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"mulVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"mulVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalise\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"normalise\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"normalise2\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"normalise2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"pitchBetween\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"pitchBetween\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"reverseVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"reverseVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"subtractVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"scaleVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"scaleVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"scaleByVector\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"scaleByVector\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"twoPi\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"twoPi\"]; });\n\n\n\n//# sourceURL=webpack://Collider/./src/modules/maths/index.js?");

/***/ }),

/***/ "./src/modules/mesh/box.js":
/*!*********************************!*\
  !*** ./src/modules/mesh/box.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths */ \"./src/modules/maths/index.js\");\n/** Simplified bounding box */\n\n\n\nclass Box extends THREE.Box3 {\n  constructor(object) {\n    // THREE.Box3 + functions\n    super();\n    this.setFromBufferAttribute(object.geometry.attributes.position);\n    this.position = new THREE.Vector3();\n  }\n\n  setPosition(p) {\n    // update position if not set\n    if (!Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"isVectorEqual\"])(this.position, p)) {\n      this.translate(Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"])(p, this.position));\n      this.position = p.clone();\n    }\n  }\n\n  distanceTo(p) {\n    return this.position.distanceTo(p);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Box);\n\n//# sourceURL=webpack://Collider/./src/modules/mesh/box.js?");

/***/ }),

/***/ "./src/modules/mesh/mesh.js":
/*!**********************************!*\
  !*** ./src/modules/mesh/mesh.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./src/modules/config.js\");\n/* harmony import */ var _plane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./plane */ \"./src/modules/mesh/plane.js\");\n/* harmony import */ var _box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./box */ \"./src/modules/mesh/box.js\");\n/* harmony import */ var _transformer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transformer */ \"./src/modules/mesh/transformer.js\");\n/* harmony import */ var _maths__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../maths */ \"./src/modules/maths/index.js\");\n/** Collision mesh */\n\n\n\n\n\n\n\nclass Mesh {\n  constructor(object) {\n    if (!object.geometry.isBufferGeometry) {\n      throw 'Error: THREE.BufferGeometry not found';\n    }\n\n    this.id = object.uuid;\n    this.isColliderMesh = true;\n    this.object = object;\n    this.geometry = object.geometry;\n    this.box = new _box__WEBPACK_IMPORTED_MODULE_2__[\"default\"](object);\n    this.planes = [];\n    this.transform = new _transformer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](object);\n    this.generatePlanes();\n    this.conformPlanes();\n  }\n\n  generatePlanes() {\n    // create planes from buffer geometry attribute\n    const verts = this.geometry.attributes.position.array;\n    const norms = this.geometry.attributes.normal.array;\n\n    if (this.geometry.index) {\n      // handle indexed geometry\n      const indices = this.geometry.index.array;\n      const size = this.geometry.attributes.position.itemSize;\n      const step = 3;\n\n      for (let i = 0; i < indices.length; i += step) {\n        const j = indices[i] * size;\n        const k = indices[i + 1] * size;\n        const l = indices[i + 2] * size;\n\n        this.planes.push(new _plane__WEBPACK_IMPORTED_MODULE_1__[\"default\"](new THREE.Vector3(verts[j], verts[j + 1], verts[j + 2]), new THREE.Vector3(verts[k], verts[k + 1], verts[k + 2]), new THREE.Vector3(verts[l], verts[l + 1], verts[l + 2]), new THREE.Vector3(norms[j], norms[j + 1], norms[j + 2]), new THREE.Vector3(norms[k], norms[k + 1], norms[k + 2]), new THREE.Vector3(norms[l], norms[l + 1], norms[l + 2])));\n      }\n    } else {\n      const step = 9;\n\n      for (let i = 0; i < verts.length; i += step) {\n        this.planes.push(new _plane__WEBPACK_IMPORTED_MODULE_1__[\"default\"](new THREE.Vector3(verts[i + 0], verts[i + 1], verts[i + 2]), new THREE.Vector3(verts[i + 3], verts[i + 4], verts[i + 5]), new THREE.Vector3(verts[i + 6], verts[i + 7], verts[i + 8]), new THREE.Vector3(norms[i + 0], norms[i + 1], norms[i + 2]), new THREE.Vector3(norms[i + 3], norms[i + 4], norms[i + 5]), new THREE.Vector3(norms[i + 6], norms[i + 7], norms[i + 8])));\n      }\n    }\n  }\n\n  conformPlanes() {\n    // NOTE: translation is handled during collision check\n    // TODO: bake all translations\n    var conformed = false;\n\n    // conform scale\n    if (!this.transform.default.scale) {\n      for (let i = 0; i < this.planes.length; i += 1) {\n        this.transform.bakeScale(this.planes[i]);\n      }\n      conformed = true;\n    }\n\n    // conform rotation\n    if (!this.transform.default.rotation) {\n      for (let i = 0; i < this.planes.length; i += 1) {\n        this.transform.bakeRotation(this.planes[i]);\n      }\n      conformed = true;\n    }\n\n    if (conformed) {\n      // regenerate plane attributes\n      for (let i = 0; i < this.planes.length; i += 1) {\n        this.planes[i].generatePlane();\n      }\n    }\n\n    // reset collision box\n    this.setBoxFromPlanes();\n  }\n\n  setBoxFromPlanes() {\n    const array = [];\n\n    for (var i = 0, len = this.planes.length; i < len; ++i) {\n      const p = this.planes[i];\n      array.push(p.p1);\n      array.push(p.p2);\n      array.push(p.p3);\n    }\n\n    this.box.setFromPoints(array);\n    this.updateBoxPosition();\n  }\n\n  updateBoxPosition() {\n    this.box.setPosition(this.transform.getPosition());\n  }\n\n  getCollision(point) {\n    if (!this.box.containsPoint(point)) {\n      return false;\n    } else {\n      // transform point to put inside baked position\n      this.transform.set(point);\n\n      // reset\n      for (var i = 0, len = this.planes.length; i < len; ++i) {\n        this.planes[i].culled = false;\n      }\n\n      // first pass - cull faces\n      for (var i = 0, len = this.planes.length; i < len; ++i) {\n        if (!this.planes[i].culled && this.planes[i].isPointBelowOrEqual(this.transform.point)) {\n          // cull planes above plane\n          for (var j = 0, jlen = this.planes.length; j < jlen; ++j) {\n            if (!this.planes[j].culled && j != i && this.planes[i].isPlaneAbove(this.planes[j])) {\n              this.planes[j].culled = true;\n            }\n          }\n        }\n      }\n\n      // second pass - get result\n      for (var i = 0, len = this.planes.length; i < len; ++i) {\n        if (!this.planes[i].culled && !this.planes[i].isPointBelowOrEqual(this.transform.point)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  getCeilingPlane(point) {\n    // get ceiling, plane above a given point\n    this.transform.set(point);\n    var ceiling = null;\n\n    for (let i = 0, len = this.planes.length; i < len; i += 1) {\n      // check general box, then precise, then for ceiling\n      if (this.planes[i].containsPoint2D(this.transform.point)) {\n        if (this.planes[i].projectedTriangleContainsPoint2D(this.transform.point) && this.planes[i].isPointBelowOrEqual(this.transform.point)) {\n          var planeCeiling = this.planes[i].getY(this.transform.point.x, this.transform.point.z);\n\n          if (planeCeiling != null && planeCeiling >= this.transform.point.y && (ceiling == null || planeCeiling > ceiling.y)) {\n            ceiling = { y: planeCeiling, plane: this.planes[i] };\n          }\n        }\n      }\n    }\n\n    return ceiling == null ? null : {\n      y: this.transform.getReverseTransformedY(ceiling.y),\n      plane: ceiling.plane\n    };\n  }\n\n  getIntersectPlane(p1, p2) {\n    const tp1 = this.transform.getTransformedPoint(p1);\n    const tp2 = this.transform.getTransformedPoint(p2);\n    const box = new THREE.Box3().setFromPoints([tp1, tp2]);\n    let intersectPlane = null;\n\n    for (let i = 0; i < this.planes.length; i += 1) {\n      if (this.planes[i].intersectsBox(box) || this.planes[i].containsBox(box)) {\n        const intersect = this.planes[i].getIntersect(tp1, tp2);\n\n        if (intersect != null) {\n          const distance = Object(_maths__WEBPACK_IMPORTED_MODULE_4__[\"distanceBetween\"])(tp1, intersect);\n\n          if (intersectPlane === null || distance < intersectPlane.distance) {\n            intersectPlane = {\n              intersect: intersect,\n              plane: this.planes[i],\n              distance: distance\n            };\n          }\n        }\n      }\n    }\n\n    return intersectPlane == null ? null : {\n      intersect: this.transform.getReverseTransformedPoint(intersectPlane.intersect),\n      plane: intersectPlane.plane,\n      distance: intersectPlane.distance\n    };\n  }\n\n  getIntersectPlane2D(p1, p2) {\n    // find 2D intersect *nearest* to p2\n\n    const tp1 = this.transform.getTransformedPoint(p1);\n    const tp2 = this.transform.getTransformedPoint(p2);\n    const box = new THREE.Box3().setFromPoints([tp1, tp2]);\n    let intersectPlane = null;\n\n    for (let i = 0; i < this.planes.length; i += 1) {\n      if (this.planes[i].intersectsBox(box) || this.planes[i].containsBox(box)) {\n        const intersect2D = this.planes[i].getNormalIntersect2D(tp2);\n\n        if (intersect2D != null) {\n          const distance = Object(_maths__WEBPACK_IMPORTED_MODULE_4__[\"distanceBetween\"])(tp2, intersect2D);\n\n          if (intersectPlane === null || distance < intersectPlane.distance) {\n            intersectPlane = {\n              plane: this.planes[i],\n              intersect: intersect2D,\n              distance: distance\n            };\n          }\n        }\n      }\n    }\n\n    return intersectPlane == null ? null : {\n      intersect: this.transform.getReverseTransformedPoint(intersectPlane.intersect),\n      plane: intersectPlane.plane,\n      distance: intersectPlane.distance\n    };\n  }\n\n  getProjected(point, plane) {\n    // get point projected onto plane\n\n    const p = this.transform.getTransformedPoint(point);\n    const proj = plane.getProjected(p);\n    return this.transform.getReverseTransformedPoint(proj);\n  }\n\n  distanceTo(point) {\n    return this.box.distanceTo(point);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mesh);\n\n//# sourceURL=webpack://Collider/./src/modules/mesh/mesh.js?");

/***/ }),

/***/ "./src/modules/mesh/plane.js":
/*!***********************************!*\
  !*** ./src/modules/mesh/plane.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _maths_general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths/general */ \"./src/modules/maths/general.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./src/modules/config.js\");\n/** Plane */\n\n\n\n\nclass Plane {\n  constructor(p1, p2, p3, n1, n2, n3) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.p3 = p3;\n    this.n1 = n1;\n    this.n2 = n2;\n    this.n3 = n3;\n    this.culled = false;\n\n    // set first state\n    this.generatePlane();\n  }\n\n  generatePlane() {\n    // generate plane data\n    this.e1 = {};\n    this.e2 = {};\n    this.e3 = {};\n    this.e1.centre = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"scaleVector\"](_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"addVector\"](this.p1, this.p2), 0.5);\n    this.e2.centre = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"scaleVector\"](_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"addVector\"](this.p2, this.p3), 0.5);\n    this.e3.centre = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"scaleVector\"](_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"addVector\"](this.p3, this.p1), 0.5);\n    this.e1.vec = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](this.p2, this.p1);\n    this.e2.vec = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](this.p3, this.p2);\n    this.e3.vec = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](this.p1, this.p3);\n\n    // 2D component & 2D normal\n    this.e1.vec2 = new THREE.Vector2(this.e1.vec.x, this.e1.vec.z);\n    this.e2.vec2 = new THREE.Vector2(this.e2.vec.x, this.e2.vec.z);\n    this.e3.vec2 = new THREE.Vector2(this.e3.vec.x, this.e3.vec.z);\n    this.e1.norm2 = new THREE.Vector2(-this.e1.vec.z, this.e1.vec.x);\n    this.e2.norm2 = new THREE.Vector2(-this.e2.vec.z, this.e2.vec.x);\n    this.e3.norm2 = new THREE.Vector2(-this.e3.vec.z, this.e3.vec.x);\n\n    // normal\n    this.normal = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"normalise\"](_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"crossProduct\"](this.e3.vec, this.e1.vec));\n    this.normalXZ = new THREE.Vector3(this.normal.x, 0, this.normal.z);\n\n    // reverse naughty normals\n    if (_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](this.normal, this.n1) < 0 && _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](this.normal, this.n2) < 0 && _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](this.normal, this.n3) < 0) {\n      this.normal = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"reverseVector\"](this.normal);\n    }\n\n    // position\n    this.position = new THREE.Vector3((this.p1.x + this.p2.x + this.p3.x) / 3, (this.p1.y + this.p2.y + this.p3.y) / 3, (this.p1.z + this.p2.z + this.p3.z) / 3);\n\n    // cache D for solving plane\n    this.D = -(this.normal.x * this.position.x) - this.normal.y * this.position.y - this.normal.z * this.position.z;\n\n    // bounding box\n    this.box = new THREE.Box3().setFromPoints([this.p1, this.p2, this.p3]);\n  }\n\n  getY(x, z) {\n    // solve plane\n    if (this.normal.y != 0) {\n      return (this.normal.x * x + this.normal.z * z + this.D) / -this.normal.y;\n    } else {\n      return null;\n    }\n  }\n\n  isPlaneAbove(plane) {\n    return this.isPointAboveOrEqual(plane.p1) && this.isPointAboveOrEqual(plane.p2) && this.isPointAboveOrEqual(plane.p3);\n  }\n\n  isPointAboveOrEqual(point) {\n    // is point above or on surface\n    return _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](point, this.position), this.normal) >= -_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].plane.dotThreshold;\n  }\n\n  isPointBelowOrEqual(point) {\n    // is point below or on surface\n    return _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](_maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](point, this.position), this.normal) <= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].plane.dotThreshold;\n  }\n\n  containsBox(box) {\n    return this.box.containsBox(box);\n  }\n\n  intersectsBox(box) {\n    return this.box.intersectsBox(box);\n  }\n\n  containsPoint2D(point) {\n    // is x, z inside bounding box\n    return this.box.min.x <= point.x && this.box.max.x >= point.x && this.box.min.z <= point.z && this.box.max.z >= point.z;\n  }\n\n  projectedTriangleContainsPoint2D(point) {\n    // is point inside projected triangle\n    return _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct2\"]({ x: point.x - this.e1.centre.x, y: point.z - this.e1.centre.z }, this.e1.norm2) < _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].plane.dotThreshold && _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct2\"]({ x: point.x - this.e2.centre.x, y: point.z - this.e2.centre.z }, this.e2.norm2) < _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].plane.dotThreshold && _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct2\"]({ x: point.x - this.e3.centre.x, y: point.z - this.e3.centre.z }, this.e3.norm2) < _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].plane.dotThreshold;\n  }\n\n  distanceToPlane(point) {\n    return Math.abs(this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.D);\n  }\n\n  getProjected(point) {\n    // project point onto plane\n    const vec = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](point, this.p1);\n    const dist = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](this.normal, vec);\n    const proj = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](point, _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"scaleVector\"](this.normal, dist));\n    return proj;\n  }\n\n  getIntersect(p1, p2) {\n    // get intersection of plane and line between p1, p2\n    const vec = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](p2, p1);\n    const dot = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"dotProduct\"](this.normal, _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"normalise\"](vec));\n\n    // check for parallel lines\n    if (Math.abs(dot) <= _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].plane.dotThreshold) {\n      return null;\n    }\n\n    const numPart = this.normal.x * p1.x + this.normal.y * p1.y + this.normal.z * p1.z + this.D;\n    const denom = this.normal.x * vec.x + this.normal.y * vec.y + this.normal.z * vec.z;\n\n    // invalid\n    if (denom == 0) {\n      return null;\n    }\n\n    const x = p1.x - vec.x * numPart / denom;\n    const y = p1.y - vec.y * numPart / denom;\n    const z = p1.z - vec.z * numPart / denom;\n    const point = new THREE.Vector3(x, y, z);\n\n    // return intersect if point is inside verts & line\n    if (this.box.containsPoint(point)) {\n      const box = new THREE.Box3().setFromPoints([p2, p1]).expandByScalar(0.05);\n\n      if (box.containsPoint(point)) {\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  getNormalIntersect(point) {\n    // get intersect which extends normal vector (or inverse) to point\n    const point2 = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"addVector\"](point, this.normal);\n    const vec = _maths_general__WEBPACK_IMPORTED_MODULE_0__[\"subtractVector\"](point2, point);\n    const numPart = this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.D;\n    const denom = this.normal.x * vec.x + this.normal.y * vec.y + this.normal.z * vec.z;\n    const x = point.x - vec.x * numPart / denom;\n    const y = point.y - vec.y * numPart / denom;\n    const z = point.z - vec.z * numPart / denom;\n    const intersect = new THREE.Vector3(x, y, z);\n\n    return intersect;\n  }\n\n  getNormalIntersect2D(point) {\n    // get 2D (xz) intersect which extends from point to surface\n    const numPart = this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.D;\n    const denom = this.normal.x * this.normal.x + this.normal.z * this.normal.z;\n\n    if (denom == 0) {\n      return null;\n    } else {\n      return new THREE.Vector3(point.x - this.normal.x * numPart / denom, point.y, point.z - this.normal.z * numPart / denom);\n    }\n  }\n\n  getPerpendicularNormals() {\n    return {\n      right: new THREE.Vector3(-this.normal.z, 0, this.normal.x),\n      left: new THREE.Vector3(this.normal.z, 0, -this.normal.x)\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Plane);\n\n//# sourceURL=webpack://Collider/./src/modules/mesh/plane.js?");

/***/ }),

/***/ "./src/modules/mesh/transformer.js":
/*!*****************************************!*\
  !*** ./src/modules/mesh/transformer.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths */ \"./src/modules/maths/index.js\");\n/** Transform vertex data */\n\n\n\nclass Transformer {\n  constructor(object) {\n    // bake initial transformations into vertex data\n    this.point = new THREE.Vector3();\n    this.position = object.position;\n    this.rotation = object.rotation;\n    this.scale = object.scale;\n    this.rotationOrder = object.rotation.order.split('');\n    this.axis = {\n      x: new THREE.Vector3(1, 0, 0),\n      y: new THREE.Vector3(0, 1, 0),\n      z: new THREE.Vector3(0, 0, 1)\n    };\n    this.checkDefault();\n  }\n\n  set(point) {\n    // transform point\n    this.point.x = point.x - this.position.x;\n    this.point.y = point.y - this.position.y;\n    this.point.z = point.z - this.position.z;\n  }\n\n  getTransformedPoint(point) {\n    const transformed = {\n      x: point.x - this.position.x,\n      y: point.y - this.position.y,\n      z: point.z - this.position.z\n    };\n\n    return transformed;\n  }\n\n  getReverseTransformedPoint(point) {\n    const transformed = {\n      x: point.x + this.position.x,\n      y: point.y + this.position.y,\n      z: point.z + this.position.z\n    };\n\n    return transformed;\n  }\n\n  getReverseTransformedY(y) {\n    return y + this.position.y;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  bakeRotation(plane) {\n    for (let i = this.rotationOrder.length - 1, end = -1; i > end; --i) {\n      if (this.rotationOrder[i] == 'X') {\n        plane.p1.applyAxisAngle(this.axis.x, this.rotation.x);\n        plane.p2.applyAxisAngle(this.axis.x, this.rotation.x);\n        plane.p3.applyAxisAngle(this.axis.x, this.rotation.x);\n        plane.n1.applyAxisAngle(this.axis.x, this.rotation.x);\n        plane.n2.applyAxisAngle(this.axis.x, this.rotation.x);\n        plane.n3.applyAxisAngle(this.axis.x, this.rotation.x);\n      } else if (this.rotationOrder[i] == 'Y') {\n        plane.p1.applyAxisAngle(this.axis.y, this.rotation.y);\n        plane.p2.applyAxisAngle(this.axis.y, this.rotation.y);\n        plane.p3.applyAxisAngle(this.axis.y, this.rotation.y);\n        plane.n1.applyAxisAngle(this.axis.y, this.rotation.y);\n        plane.n2.applyAxisAngle(this.axis.y, this.rotation.y);\n        plane.n3.applyAxisAngle(this.axis.y, this.rotation.y);\n      } else if (this.rotationOrder[i] == 'Z') {\n        plane.p1.applyAxisAngle(this.axis.z, this.rotation.z);\n        plane.p2.applyAxisAngle(this.axis.z, this.rotation.z);\n        plane.p3.applyAxisAngle(this.axis.z, this.rotation.z);\n        plane.n1.applyAxisAngle(this.axis.z, this.rotation.z);\n        plane.n2.applyAxisAngle(this.axis.z, this.rotation.z);\n        plane.n3.applyAxisAngle(this.axis.z, this.rotation.z);\n      }\n    }\n  }\n\n  bakeScale(plane) {\n    plane.p1 = _maths__WEBPACK_IMPORTED_MODULE_0__[\"scaleByVector\"](plane.p1, this.scale);\n    plane.p2 = _maths__WEBPACK_IMPORTED_MODULE_0__[\"scaleByVector\"](plane.p2, this.scale);\n    plane.p3 = _maths__WEBPACK_IMPORTED_MODULE_0__[\"scaleByVector\"](plane.p3, this.scale);\n  }\n\n  checkDefault() {\n    // check if transforms are set to default\n    this.default = {\n      position: this.position.x == 0 && this.position.y == 0 && this.position.z == 0,\n      rotation: this.rotation.x == 0 && this.rotation.y == 0 && this.rotation.z == 0,\n      scale: this.scale.x == 1 && this.scale.y == 1 && this.scale.z == 1\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Transformer);\n\n//# sourceURL=webpack://Collider/./src/modules/mesh/transformer.js?");

/***/ }),

/***/ "./src/modules/point.js":
/*!******************************!*\
  !*** ./src/modules/point.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./src/modules/config.js\");\n/** Collider.Point */\n\n\n\nclass Point {\n  constructor(settings) {\n    this.settings = _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].settings;\n    this.set(settings || {});\n  }\n\n  set(settings) {\n    // replace defaults\n    Object.keys(settings).forEach(key => {\n      if (this.settings[key] !== undefined && typeof this.settings[key] === settings[key]) {\n        this.settings[key] = settings[key];\n      }\n    });\n\n    // set position\n    this.position = settings.position || new THREE.Vector3();\n    this.motion = settings.motion || new THREE.Vector3();\n  }\n\n  setMotion(v) {\n    this.motion.x = v.x;\n    this.motion.y = v.y;\n    this.motion.z = v.z;\n  }\n\n  collide(system, delta) {\n    // get next position & apply physics\n    const p = Maths.addVector(this.position, Maths.scaleVector(this.motion, delta));\n    this.falling = this.motion.y < 0;\n    this.motion.y = Math.max(this.motion.y - this.settings.gravity * delta, -this.settings.maxVelocity);\n\n    // collide\n    let collisions = system.getCollisions(p);\n\n    // slopes/ walls\n    if (collisions.length > 0) {\n      if (this.stepUpSlopes(p, collisions)) {\n        collisions = system.getCollisions(p);\n      }\n      if (this.extrudeFrom(p, collisions, system)) {\n        this.stepUpSlopes(p, system.getCollisions(p));\n      }\n    } else if (this.motion.y < 0 && !this.falling) {\n      this.stepDownSlope(p, system.getCeilingPlane(new THREE.Vector3(p.x, p.y - this.settings.snapDown, p.z)));\n    }\n\n    // floor limit\n    if (p.y < this.settings.floor) {\n      this.motion.y = 0;\n      p.y = this.settings.floor;\n    }\n\n    this.position.copy(p);\n  }\n\n  getValidCollisions(p, meshes) {\n    // get n collisions with meshes that can't be climbed\n    var hits = 0;\n\n    for (var i = 0, len = meshes.length; i < len; ++i) {\n      const ceiling = meshes[i].getCeilingPlane(p);\n      if (ceiling != null && (ceiling.plane.normal.y < this.settings.minSlope || ceiling.y - this.position.y > this.settings.snapUp)) {\n        hits++;\n      }\n    }\n\n    return hits;\n  }\n\n  extrudeFrom(p, meshes, system) {\n    // extrude position from obstructions\n    var isExtruded = false;\n    var mesh = false;\n\n    for (let i = 0, len = meshes.length; i < len; ++i) {\n      const ceiling = meshes[i].getCeilingPlane(p);\n      if (ceiling != null && (ceiling.plane.normal.y < this.settings.minSlope || ceiling.y - this.position.y > this.settings.snapUp)) {\n        mesh = meshes[i];\n        break;\n      }\n    }\n\n    // extrude from mesh\n    if (mesh) {\n      const intersectPlane = mesh.getIntersectPlane2D(this.position, p);\n\n      if (intersectPlane != null) {\n        const intersect = intersectPlane.intersect;\n        const plane = intersectPlane.plane;\n\n        if (plane.normal.y < -0.5) {\n          // project in 3D, if other mesh collisions, try 2D\n          // NOTE: needs refinement\n          const proj = mesh.getProjected(p, plane);\n          const hits = this.getValidCollisions(proj, system.getCollisions(proj));\n\n          // stop motion if cornered\n          if (hits > 1) {\n            p.x = this.position.x;\n            p.z = this.position.z;\n          } else {\n            p.x = proj.x;\n            p.y = proj.y;\n            p.z = proj.z;\n            // reduce jump motion\n            this.motion.y = this.motion.y > 0 ? this.motion.y * 0.75 : this.motion.y;\n            //this.motion.y = Math.min(-0.01, this.motion.y);\n            isExtruded = true;\n          }\n        } else {\n          p.x = intersect.x;\n          p.z = intersect.z;\n          const hits = this.getValidCollisions(p, system.getCollisions(p));\n\n          // stop motion if cornered\n          if (hits > 1) {\n            p.x = this.position.x;\n            p.z = this.position.z;\n          } else {\n            isExtruded = true;\n          }\n        }\n      } else {\n        p.x = this.position.x;\n        p.z = this.position.z;\n      }\n    }\n\n    return isExtruded;\n  }\n\n  stepUpSlopes(position, meshes) {\n    let steppedUp = false;\n    for (let i = 0, len = meshes.length; i < len; ++i) {\n      const ceiling = meshes[i].getCeilingPlane(position);\n      // climb up slopes\n      if (ceiling != null && ceiling.plane.normal.y >= this.settings.minSlope && ceiling.y - this.position.y <= this.settings.snapUp) {\n        if (ceiling.y >= position.y) {\n          steppedUp = true;\n          position.y = ceiling.y;\n          this.motion.y = 0;\n        }\n      }\n    }\n    return steppedUp;\n  }\n\n  stepDownSlope(position, ceilingPlane) {\n    let steppedDown = false;\n    if (ceilingPlane != null && ceilingPlane.plane.normal.y >= this.settings.minSlope) {\n      position.y = ceilingPlane.y;\n      this.motion.y = 0;\n      steppedDown = true;\n    }\n    return steppedDown;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Point);\n\n//# sourceURL=webpack://Collider/./src/modules/point.js?");

/***/ }),

/***/ "./src/modules/system.js":
/*!*******************************!*\
  !*** ./src/modules/system.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mesh_mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mesh/mesh */ \"./src/modules/mesh/mesh.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./src/modules/config.js\");\n/** Collider.System */\n\n\n\n\nclass System {\n  constructor() {\n    this.meshes = [];\n    this.cache = [];\n    this.settings = _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].system;\n    this.isColliderSystem = true;\n  }\n\n  add() {\n    // add meshes to system\n    for (let i = 0, len = arguments.length; i < len; ++i) {\n      let mesh = arguments[i];\n      if (!mesh.isColliderMesh && mesh.geometry && mesh.geometry.isBufferGeometry) {\n        mesh = new _mesh_mesh__WEBPACK_IMPORTED_MODULE_0__[\"default\"](mesh);\n      }\n      if (mesh.isColliderMesh) {\n        if (mesh.planes.length < _config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].system.maxPlanesPerMesh) {\n          this.meshes.push(mesh);\n        } else {\n          console.warn(`Mesh plane count exceeds maximum (${_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].system.maxPlanesPerMesh})`);\n        }\n      }\n    }\n  }\n\n  getCollisions(point) {\n    // get system collision with point\n    const res = [];\n    const meshes = this.settings.useCache ? this.cache : this.meshes;\n    for (let i = 0, len = meshes.length; i < len; ++i) {\n      if (meshes[i].getCollision(point)) {\n        res.push(meshes[i]);\n      }\n    }\n    return res;\n  }\n\n  getCeilingPlane(point) {\n    // get ceiling above point\n    let ceiling = null;\n    const meshes = this.getCollisions(point);\n    for (let i = 0, len = meshes.length; i < len; ++i) {\n      const res = meshes[i].getCeilingPlane(point);\n      if (res && (!ceiling || res.y > ceiling.y)) {\n        ceiling = { y: res.y, plane: res.plane };\n      }\n    }\n    return ceiling;\n  }\n\n  cache(point) {\n    // add nearby meshes to cache\n    this.cache = [];\n    for (let i = 0, len = this.meshes.length; i < len; ++i) {\n      if (this.meshes[i].distanceTo(point) < this.settings.cacheRadius) {\n        this.cache.push(this.meshes[i]);\n      }\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (System);\n\n//# sourceURL=webpack://Collider/./src/modules/system.js?");

/***/ })

/******/ });