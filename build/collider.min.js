var Collider=function(t){var s={};function e(i){if(s[i])return s[i].exports;var n=s[i]={i:i,l:!1,exports:{}};return t[i].call(n.exports,n,n.exports,e),n.l=!0,n.exports}return e.m=t,e.c=s,e.d=function(t,s,i){e.o(t,s)||Object.defineProperty(t,s,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,s){if(1&s&&(t=e(t)),8&s)return t;if(4&s&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&s&&"string"!=typeof t)for(var n in t)e.d(i,n,function(s){return t[s]}.bind(null,n));return i},e.n=function(t){var s=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(s,"a",s),s},e.o=function(t,s){return Object.prototype.hasOwnProperty.call(t,s)},e.p="",e(e.s=0)}([function(t,s,e){"use strict";e.r(s);var i={system:{maxPlanesPerMesh:200,useCache:!1,cacheRadius:20},settings:{gravity:10,floor:0,maxVelocity:50,friction:.5,snapUp:.75,snapDown:.5,minSlope:Math.PI/5,noclip:!1},plane:{dotThreshold:.001,collisionThreshold:.5}};Math.PI;const n=function(t,s){return new THREE.Vector3(t.x+s.x,t.y+s.y,t.z+s.z)},o=function(t,s){return new THREE.Vector3(t.x-s.x,t.y-s.y,t.z-s.z)},r=function(t){const s=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);return 0==s?new THREE.Vector3(0,0,0):new THREE.Vector3(t.x/s,t.y/s,t.z/s)},h=function(t){return t.x*=-1,t.y*=-1,t.z*=-1,t},l=function(t,s){return Math.sqrt(Math.pow(s.x-t.x,2)+Math.pow(s.y-t.y,2)+Math.pow(s.z-t.z,2))},a=function(t,s){return new THREE.Vector3(t.x*s,t.y*s,t.z*s)},p=function(t,s){return new THREE.Vector3(t.x*s.x,t.y*s.y,t.z*s.z)},c=function(t,s){return t.x===s.x&&t.y===s.y&t.z===s.z},x=function(t,s){return new THREE.Vector3(t.y*s.z-t.z*s.y,t.z*s.x-t.x*s.z,t.x*s.y-t.y*s.x)},y=function(t,s){return t.x*s.x+t.y*s.y+t.z*s.z},m=function(t,s){return t.x*s.x+t.y*s.y};var u=class{constructor(t,s,e,i,n,o){this.p1=t,this.p2=s,this.p3=e,this.n1=i,this.n2=n,this.n3=o,this.culled=!1,this.generatePlane()}generatePlane(){this.e1={},this.e2={},this.e3={},this.e1.centre=a(n(this.p1,this.p2),.5),this.e2.centre=a(n(this.p2,this.p3),.5),this.e3.centre=a(n(this.p3,this.p1),.5),this.e1.vec=o(this.p2,this.p1),this.e2.vec=o(this.p3,this.p2),this.e3.vec=o(this.p1,this.p3),this.e1.vec2=new THREE.Vector2(this.e1.vec.x,this.e1.vec.z),this.e2.vec2=new THREE.Vector2(this.e2.vec.x,this.e2.vec.z),this.e3.vec2=new THREE.Vector2(this.e3.vec.x,this.e3.vec.z),this.e1.norm2=new THREE.Vector2(-this.e1.vec.z,this.e1.vec.x),this.e2.norm2=new THREE.Vector2(-this.e2.vec.z,this.e2.vec.x),this.e3.norm2=new THREE.Vector2(-this.e3.vec.z,this.e3.vec.x),this.normal=r(x(this.e3.vec,this.e1.vec)),this.normalXZ=new THREE.Vector3(this.normal.x,0,this.normal.z),y(this.normal,this.n1)<0&&y(this.normal,this.n2)<0&&y(this.normal,this.n3)<0&&(this.normal=h(this.normal)),this.position=new THREE.Vector3((this.p1.x+this.p2.x+this.p3.x)/3,(this.p1.y+this.p2.y+this.p3.y)/3,(this.p1.z+this.p2.z+this.p3.z)/3),this.D=-this.normal.x*this.position.x-this.normal.y*this.position.y-this.normal.z*this.position.z,this.box=(new THREE.Box3).setFromPoints([this.p1,this.p2,this.p3])}getY(t,s){return 0!=this.normal.y?(this.normal.x*t+this.normal.z*s+this.D)/-this.normal.y:null}isPlaneAbove(t){return this.isPointAboveOrEqual(t.p1)&&this.isPointAboveOrEqual(t.p2)&&this.isPointAboveOrEqual(t.p3)}isPointAboveOrEqual(t){return y(o(t,this.position),this.normal)>=-i.plane.dotThreshold}isPointBelowOrEqual(t){return y(o(t,this.position),this.normal)<=i.plane.dotThreshold}containsBox(t){return this.box.containsBox(t)}intersectsBox(t){return this.box.intersectsBox(t)}containsPoint2D(t){return this.box.min.x<=t.x&&this.box.max.x>=t.x&&this.box.min.z<=t.z&&this.box.max.z>=t.z}projectedTriangleContainsPoint2D(t){return m({x:t.x-this.e1.centre.x,y:t.z-this.e1.centre.z},this.e1.norm2)<i.plane.dotThreshold&&m({x:t.x-this.e2.centre.x,y:t.z-this.e2.centre.z},this.e2.norm2)<i.plane.dotThreshold&&m({x:t.x-this.e3.centre.x,y:t.z-this.e3.centre.z},this.e3.norm2)<i.plane.dotThreshold}distanceToPlane(t){return Math.abs(this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D)}getProjected(t){const s=o(t,this.p1),e=y(this.normal,s);return o(t,a(this.normal,e))}getIntersect(t,s){const e=o(s,t),n=y(this.normal,r(e));if(Math.abs(n)<=i.plane.dotThreshold)return null;const h=this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D,l=this.normal.x*e.x+this.normal.y*e.y+this.normal.z*e.z;if(0==l)return null;const a=t.x-e.x*h/l,p=t.y-e.y*h/l,c=t.z-e.z*h/l,x=new THREE.Vector3(a,p,c);return this.box.containsPoint(x)&&(new THREE.Box3).setFromPoints([s,t]).expandByScalar(.05).containsPoint(x)?x:null}getNormalIntersect(t){const s=n(t,this.normal),e=o(s,t),i=this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D,r=this.normal.x*e.x+this.normal.y*e.y+this.normal.z*e.z,h=t.x-e.x*i/r,l=t.y-e.y*i/r,a=t.z-e.z*i/r;return new THREE.Vector3(h,l,a)}getNormalIntersect2D(t){const s=this.normal.x*t.x+this.normal.y*t.y+this.normal.z*t.z+this.D,e=this.normal.x*this.normal.x+this.normal.z*this.normal.z;return 0==e?null:new THREE.Vector3(t.x-this.normal.x*s/e,t.y,t.z-this.normal.z*s/e)}getPerpendicularNormals(){return{right:new THREE.Vector3(-this.normal.z,0,this.normal.x),left:new THREE.Vector3(this.normal.z,0,-this.normal.x)}}};var g=class extends THREE.Box3{constructor(t){super(),this.setFromBufferAttribute(t.geometry.attributes.position),this.position=new THREE.Vector3}setPosition(t){c(this.position,t)||(this.translate(o(t,this.position)),this.position=t.clone())}distanceTo(t){return this.position.distanceTo(t)}};var f=class{constructor(t){this.point=new THREE.Vector3,this.position=t.position,this.rotation=t.rotation,this.scale=t.scale,this.rotationOrder=t.rotation.order.split(""),this.axis={x:new THREE.Vector3(1,0,0),y:new THREE.Vector3(0,1,0),z:new THREE.Vector3(0,0,1)},this.checkDefault()}set(t){this.point.x=t.x-this.position.x,this.point.y=t.y-this.position.y,this.point.z=t.z-this.position.z}getTransformedPoint(t){return{x:t.x-this.position.x,y:t.y-this.position.y,z:t.z-this.position.z}}getReverseTransformedPoint(t){return{x:t.x+this.position.x,y:t.y+this.position.y,z:t.z+this.position.z}}getReverseTransformedY(t){return t+this.position.y}getPosition(){return this.position}bakeRotation(t){for(let s=this.rotationOrder.length-1,e=-1;s>e;--s)"X"==this.rotationOrder[s]?(t.p1.applyAxisAngle(this.axis.x,this.rotation.x),t.p2.applyAxisAngle(this.axis.x,this.rotation.x),t.p3.applyAxisAngle(this.axis.x,this.rotation.x),t.n1.applyAxisAngle(this.axis.x,this.rotation.x),t.n2.applyAxisAngle(this.axis.x,this.rotation.x),t.n3.applyAxisAngle(this.axis.x,this.rotation.x)):"Y"==this.rotationOrder[s]?(t.p1.applyAxisAngle(this.axis.y,this.rotation.y),t.p2.applyAxisAngle(this.axis.y,this.rotation.y),t.p3.applyAxisAngle(this.axis.y,this.rotation.y),t.n1.applyAxisAngle(this.axis.y,this.rotation.y),t.n2.applyAxisAngle(this.axis.y,this.rotation.y),t.n3.applyAxisAngle(this.axis.y,this.rotation.y)):"Z"==this.rotationOrder[s]&&(t.p1.applyAxisAngle(this.axis.z,this.rotation.z),t.p2.applyAxisAngle(this.axis.z,this.rotation.z),t.p3.applyAxisAngle(this.axis.z,this.rotation.z),t.n1.applyAxisAngle(this.axis.z,this.rotation.z),t.n2.applyAxisAngle(this.axis.z,this.rotation.z),t.n3.applyAxisAngle(this.axis.z,this.rotation.z))}bakeScale(t){t.p1=p(t.p1,this.scale),t.p2=p(t.p2,this.scale),t.p3=p(t.p3,this.scale)}checkDefault(){this.default={position:0==this.position.x&&0==this.position.y&&0==this.position.z,rotation:0==this.rotation.x&&0==this.rotation.y&&0==this.rotation.z,scale:1==this.scale.x&&1==this.scale.y&&1==this.scale.z}}};var d=class{constructor(t){if(!t.geometry.isBufferGeometry)throw"Error: THREE.BufferGeometry not found";this.id=t.uuid,this.isColliderMesh=!0,this.enabled=!0,this.object=t,this.geometry=t.geometry,this.box=new g(t),this.planes=[],this.transform=new f(t),this.generatePlanes(),this.conformPlanes()}disable(){this.enabled=!1}enable(){this.enabled=!0}generatePlanes(){const t=this.geometry.attributes.position.array,s=this.geometry.attributes.normal.array;if(this.geometry.index){const e=this.geometry.index.array,i=this.geometry.attributes.position.itemSize,n=3;for(let o=0;o<e.length;o+=n){const n=e[o]*i,r=e[o+1]*i,h=e[o+2]*i;this.planes.push(new u(new THREE.Vector3(t[n],t[n+1],t[n+2]),new THREE.Vector3(t[r],t[r+1],t[r+2]),new THREE.Vector3(t[h],t[h+1],t[h+2]),new THREE.Vector3(s[n],s[n+1],s[n+2]),new THREE.Vector3(s[r],s[r+1],s[r+2]),new THREE.Vector3(s[h],s[h+1],s[h+2])))}}else{const e=9;for(let i=0;i<t.length;i+=e)this.planes.push(new u(new THREE.Vector3(t[i+0],t[i+1],t[i+2]),new THREE.Vector3(t[i+3],t[i+4],t[i+5]),new THREE.Vector3(t[i+6],t[i+7],t[i+8]),new THREE.Vector3(s[i+0],s[i+1],s[i+2]),new THREE.Vector3(s[i+3],s[i+4],s[i+5]),new THREE.Vector3(s[i+6],s[i+7],s[i+8])))}}conformPlanes(){var t=!1;if(!this.transform.default.scale){for(let t=0;t<this.planes.length;t+=1)this.transform.bakeScale(this.planes[t]);t=!0}if(!this.transform.default.rotation){for(let t=0;t<this.planes.length;t+=1)this.transform.bakeRotation(this.planes[t]);t=!0}if(t)for(let t=0;t<this.planes.length;t+=1)this.planes[t].generatePlane();this.setBoxFromPlanes()}setBoxFromPlanes(){const t=[];for(var s=0,e=this.planes.length;s<e;++s){const e=this.planes[s];t.push(e.p1),t.push(e.p2),t.push(e.p3)}this.box.setFromPoints(t),this.updateBoxPosition()}updateBoxPosition(){this.box.setPosition(this.transform.getPosition())}getCollision(t){if(this.enabled&&this.box.containsPoint(t)){this.transform.set(t);for(var s=0,e=this.planes.length;s<e;++s)this.planes[s].culled=!1;for(s=0,e=this.planes.length;s<e;++s)if(!this.planes[s].culled&&this.planes[s].isPointBelowOrEqual(this.transform.point))for(var i=0,n=this.planes.length;i<n;++i)!this.planes[i].culled&&i!=s&&this.planes[s].isPlaneAbove(this.planes[i])&&(this.planes[i].culled=!0);for(s=0,e=this.planes.length;s<e;++s)if(!this.planes[s].culled&&!this.planes[s].isPointBelowOrEqual(this.transform.point))return!1;return!0}return!1}getCeilingPlane(t){this.transform.set(t);var s=null;for(let t=0,i=this.planes.length;t<i;t+=1)if(this.planes[t].containsPoint2D(this.transform.point)&&this.planes[t].projectedTriangleContainsPoint2D(this.transform.point)&&this.planes[t].isPointBelowOrEqual(this.transform.point)){var e=this.planes[t].getY(this.transform.point.x,this.transform.point.z);null!=e&&e>=this.transform.point.y&&(null==s||e>s.y)&&(s={y:e,plane:this.planes[t]})}return null==s?null:{y:this.transform.getReverseTransformedY(s.y),plane:s.plane}}getIntersectPlane(t,s){const e=this.transform.getTransformedPoint(t),i=this.transform.getTransformedPoint(s),n=(new THREE.Box3).setFromPoints([e,i]);let o=null;for(let t=0;t<this.planes.length;t+=1)if(this.planes[t].intersectsBox(n)||this.planes[t].containsBox(n)){const s=this.planes[t].getIntersect(e,i);if(null!=s){const i=l(e,s);(null===o||i<o.distance)&&(o={intersect:s,plane:this.planes[t],distance:i})}}return null==o?null:{intersect:this.transform.getReverseTransformedPoint(o.intersect),plane:o.plane,distance:o.distance}}getIntersectPlane2D(t,s){const e=this.transform.getTransformedPoint(t),i=this.transform.getTransformedPoint(s),n=(new THREE.Box3).setFromPoints([e,i]);let o=null;for(let t=0;t<this.planes.length;t+=1)if(this.planes[t].intersectsBox(n)||this.planes[t].containsBox(n)){const s=this.planes[t].getNormalIntersect2D(i);if(null!=s){const e=l(i,s);(null===o||e<o.distance)&&(o={plane:this.planes[t],intersect:s,distance:e})}}return null==o?null:{intersect:this.transform.getReverseTransformedPoint(o.intersect),plane:o.plane,distance:o.distance}}getProjected(t,s){const e=this.transform.getTransformedPoint(t),i=s.getProjected(e);return this.transform.getReverseTransformedPoint(i)}distanceTo(t){return this.box.distanceTo(t)}};var z=class{constructor(){this.meshes=[],this.cache=[],this.settings=i.system,this.isColliderSystem=!0}add(){let t=null;for(let s=0,e=arguments.length;s<e;++s){let e=arguments[s];e.type&&"Group"===e.type?e.children.forEach(t=>{this.add(t)}):(!e.isColliderMesh&&e.geometry&&e.geometry.isBufferGeometry&&(e=new d(e)),e.isColliderMesh&&(e.planes.length<i.system.maxPlanesPerMesh?(this.meshes.push(e),t=e):console.warn(`Mesh plane count exceeds maximum (${i.system.maxPlanesPerMesh})`)))}return t}getCollisions(t){const s=[],e=this.settings.useCache?this.cache:this.meshes;for(let i=0,n=e.length;i<n;++i)e[i].getCollision(t)&&s.push(e[i]);return s}getCeilingPlane(t){let s=null;const e=this.getCollisions(t);for(let i=0,n=e.length;i<n;++i){const n=e[i].getCeilingPlane(t);n&&(!s||n.y>s.y)&&(s={y:n.y,plane:n.plane})}return s}cache(t){this.cache=[];for(let s=0,e=this.meshes.length;s<e;++s)this.meshes[s].distanceTo(t)<this.settings.cacheRadius&&this.cache.push(this.meshes[s])}};var E=class{constructor(t){this.settings=i.settings,this.set(t||{})}set(t){Object.keys(t).forEach(s=>{void 0!==this.settings[s]&&typeof this.settings[s]==typeof t[s]&&(this.settings[s]=t[s])}),this.position=t.position||new THREE.Vector3,this.motion=t.motion||new THREE.Vector3,this.system=t.system||null}collide(t){if(!this.system)return;const s=n(this.position,a(this.motion,t));this.falling=this.motion.y<0,this.motion.y=Math.max(this.motion.y-this.settings.gravity*t,-this.settings.maxVelocity);let e=this.system.getCollisions(s);e.length>0?(this.stepUpSlopes(s,e)&&(e=this.system.getCollisions(s)),this.extrudeFrom(s,e)&&this.stepUpSlopes(s,this.system.getCollisions(s))):this.motion.y<0&&!this.falling&&this.stepDownSlope(s,this.system.getCeilingPlane(new THREE.Vector3(s.x,s.y-this.settings.snapDown,s.z))),s.y<this.settings.floor&&(this.motion.y=0,s.y=this.settings.floor),this.position.copy(s)}getValidCollisions(t,s){for(var e=0,i=0,n=s.length;i<n;++i){const n=s[i].getCeilingPlane(t);null!=n&&(n.plane.normal.y<this.settings.minSlope||n.y-this.position.y>this.settings.snapUp)&&e++}return e}extrudeFrom(t,s){var e=!1,i=!1;for(let e=0,n=s.length;e<n;++e){const n=s[e].getCeilingPlane(t);if(null!=n&&(n.plane.normal.y<this.settings.minSlope||n.y-this.position.y>this.settings.snapUp)){i=s[e];break}}if(i){const s=i.getIntersectPlane2D(this.position,t);if(null!=s){const n=s.intersect,o=s.plane;if(o.normal.y<-.5){const s=i.getProjected(t,o);this.getValidCollisions(s,this.system.getCollisions(s))>1?(t.x=this.position.x,t.z=this.position.z):(t.x=s.x,t.y=s.y,t.z=s.z,this.motion.y=this.motion.y>0?.75*this.motion.y:this.motion.y,e=!0)}else t.x=n.x,t.z=n.z,this.getValidCollisions(t,this.system.getCollisions(t))>1?(t.x=this.position.x,t.z=this.position.z):e=!0}else t.x=this.position.x,t.z=this.position.z}return e}stepUpSlopes(t,s){let e=!1;for(let i=0,n=s.length;i<n;++i){const n=s[i].getCeilingPlane(t);null!=n&&n.plane.normal.y>=this.settings.minSlope&&n.y-this.position.y<=this.settings.snapUp&&n.y>=t.y&&(e=!0,t.y=n.y,this.motion.y=0)}return e}stepDownSlope(t,s){let e=!1;return null!=s&&s.plane.normal.y>=this.settings.minSlope&&(t.y=s.y,this.motion.y=0,e=!0),e}};e.d(s,"System",function(){return z}),e.d(s,"Point",function(){return E}),e.d(s,"Mesh",function(){return d})}]);